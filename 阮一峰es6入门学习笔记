
let 命令

  不存在变量提升

  暂时性死区

  不允许重复声明

块级作用域

  ES6 块级作用域 允许任意嵌套

  块级作用域和函数声明

  do 表达式 返回内部最后执行的表达式的值

const 命令

  一旦声明，必须初始化且值不能改变

  性质跟 let 一样

  本质 对象数组本身不可变，内容可变

ES6 声明变量的六种方法

  var

  function

  let

  const

  import

  class

顶层对象的属性

  顶层对象的属性与全局变量挂钩

变量的解构赋值

  解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象

  数组的解构赋值
  
    从数组和对象中提取值，对变量进行赋值，这被称为解构
  
    模式匹配
  
    	只要等号两边的模式相同，左边的变量就会被赋予对应的值
  
    	如果解构不成功，变量的值就等于undefined
  
    	等号左边的模式，只匹配一部分的等号右边的数组
  
    默认值
  
    	解构赋值允许指定默认值
  
    	默认值是一个表达式，只有在用到的时候，才会求值
  
    	默认值可以引用解构赋值的其他变量，但该变量必须已经声明
  
  对象的解构赋值
  
    解构不仅可以用于数组，还可以用于对象
  
    对象的属性没有次序，变量必须与属性同名，才能取到正确的值
  
    也可以用于解构嵌套结构的对象
  
    对象的解构也可以指定默认值
  
    	默认值生效的条件是，对象的属性值严格等于undefined
  
    	如果解构失败，变量的值等于undefined
  
    	如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错
  
  字符串的解构赋值
  
    字符串被转换成了一个类似数组的对象
  
      const [a, b, c, d, e] = 'hello';
      a // "h"
      b // "e"
      c // "l"
      d // "l"
      e // "o"
  
    类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值
  
      let {length : len} = 'hello';
      len // 5
  
  数值和布尔值的解构赋值
  
    等号右边是数值和布尔值，则会先转为对象，数值和布尔值的包装对象都有toString属性，因此都能取到值
  
      let {toString: s} = 123;
      s === Number.prototype.toString // true
  
      let {toString: s} = true;
      s === Boolean.prototype.toString // true
  
    undefined和null无法转为对象，所以对它们进行解构赋值，都会报错

  函数参数的解构赋值

    可以使用默认值

    参数可以是对象，通过对这个对象进行解构（左初始默认，右传入值）

  圆括号问题

    可以使用圆括号的情况只有一种

      赋值语句的非模式部分，可以使用圆括号

  用途

    1. 交换变量的值
    2. 从函数返回多个值
    3. 函数参数的定义
    4. 提取 JSON 数据
    5. 函数参数的默认值
    6. 遍历 Map 结构
    7. 输入模块的指定方法

字符串的扩展

  字符的 Unicode 表示法

    这种表示法只限于码点在\u0000~\uFFFF之间的字符

    超出范围的必须用两个双字节的形式表示

    超过0xFFFF的数值，将码点放入大括号，就能正确解读该字符

  codePointAt()

  String.fromCodePoint()

  字符串的遍历器接口

  at()

  normalize()

  includes(), startsWith(), endsWith()

Symbol

  JavaScript 语言的第七种数据类型

    1. ndefined
    2. null
    3. 布尔值（Boolean）
    4. 字符串（String）
    5. 数值（Number）
    6. 对象（Object）
    7. 原始数据类型（Symbol）

    Symbol 值通过 Symbol 函数生成，类似于字符串的数据类型

    属性名属于 Symbol 类型，就都是独一无二的值

    如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值

    Symbol 值不能与其他类型的值进行运算，会报错

    Symbol 值可以显式转为字符串

    Symbol 值也可以转为布尔值，但是不能转为数值

  作为属性名的 Symbol

Class 的基本语法

  简介

    class关键字，可以定义类

    类，完全可以看作构造函数的另一种写法

    类的内部所有定义的方法，都是不可枚举的

  constructor 方法
  
    constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法

  类的实例对象

    生成类的实例对象的写法，也是使用new命令

  Class 表达式

    类可以使用表达式的形式定义

    采用 Class 表达式，可以写出立即执行的 Class

  不存在变量提升

  私有方法和私有属性

    现有方法

      1. 在命名上加以区别
      2. 索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的
      3. 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值

    私有属性

      属性名之前，使用#表示

  this 的指向

    类的方法内部如果含有this，它默认指向类的实例

  name 属性

    class Point {}
    Point.name  // "Point"

  Class 的取值函数（getter）和存值函数（setter）

    在"类"的内部可以使用 get 和 set 关键字

      对某个属性设置存值函数和取值函数，拦截该属性的存取行为

  Class 的 Generator 方法

    某个方法之前加上星号（*），就表示该方法是一个 Generator 函数

  Class 的静态方法

    在一个方法前加上 static 关键字，这就称为"静态方法"

      表示该方法不会被实例继承，而是直接通过类来调用

    静态方法包含this关键字，这个this指的是类，而不是实例

    静态方法可以与非静态方法重名

    父类的静态方法，可以被子类继承

    静态方法也是可以从super对象上调用的

  Class 的静态属性和实例属性

    静态属性指的是 Class 本身的属性，即 Class.propName

    类的实例属性

      类的实例属性可以用等式，写入类的定义之中

    类的静态属性

      类的静态属性只要在上面的实例属性写法前面加上 static 关键字

  new.target 属性

    返回new命令作用于的那个构造函数

      构造函数不是通过 new 命令调用的，new.target 会返回 undefined

    Class 内部调用new.target，返回当前 Class

    子类继承父类时，new.target会返回子类

      利用这个特点，可以写出不能独立使用、必须继承后才能使用的类

Class 的继承

  简介

    Class 可以通过 extends 关键字实现继承

    super 关键字在继承的子类里表示父类的构造函数，用来新建父类的 this 对象

      子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错

      ES6 的继承机制实质是先创造父类的实例对象 this（所以必须先调用 super 方法），然后再用子类的构造函数修改 this

      子类没有定义 constructor 方法，这个方法会被默认添加

      在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错

    父类的静态方法，也会被子类继承

  Object.getPrototypeOf()

    Object.getPrototypeOf方法可以用来从子类上获取父类

  super 关键字

    这个关键字，既可以当作函数使用，也可以当作对象使用

      super 作为函数调用时，代表父类的构造函数（这是必须的，否则 JavaScript 引擎会报错）

        super() 内部的 this 指向的是子类

      super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类

        属性定义在父类的原型对象上，super 就可以取到

      通过 super 调用父类的方法时，方法内部的 this 指向子类



扩展

  冻结对象

    Object.freez(obj)

  返回对象自身可枚举属性的键值对数组

    Object.entries(obj)

  返回对象的所有可枚举属性的字符串数组

    Object.keys(obj)